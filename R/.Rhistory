s1.long <- ai
s1.long$condition2 <- s1.long$domain
s1.long$variable <- s1.long$condition
s1.long$value <- s1.long$dv
s1.long$measure <-factor(s1.long$condition2,  levels = c(1,2,3,4), labels = c("Court","Hiring","Admissions","Healthcare"))
s1.long$target <-factor(s1.long$variable,  levels = c(0,1,2,3), labels = c("Control", "Codebook", "AI", "Human"))
s.1dtamean = s1.long %>% group_by(target,measure) %>% summarise(meanval = mean(value, na.rm=T), se = ci2(value))
s.1dtamean$selow = s.1dtamean$meanval - s.1dtamean$se
s.1dtamean$sehi = s.1dtamean$meanval + s.1dtamean$se
# Create plot
plot.study1 <- ggplot()+
geom_bar(data = s.1dtamean, aes(x = target, fill = measure, y = meanval),position ='dodge', stat = 'identity', with = .5, colour = "black") +
geom_errorbar(data = s.1dtamean, aes(x = target, fill = target,ymin = selow, ymax = sehi, width = .4),position = 'dodge') +
theme_classic() + # Make graph background blank
facet_grid(. ~ measure)+ #for horizontal faceting, use: facet_wrap(~measure)
geom_jitter(data = s1.long, aes(color = target, x = target, group = target,y = value), alpha = .3)+
labs(title="", x="", y = "Average Responsibility") +
scale_fill_manual(name = '',values=c('#ffffff', '#ffffff',"#ffffff","#ffffff","#ffffff","#ffffff","#ffffff","#ffffff",'#ffffff', '#ffffff',"#ffffff","#ffffff","#ffffff","#ffffff","#ffffff","#ffffff"))+ #makes bars filled with white (#f0f0f0 for off-white), but also adds the unnecessary legend
theme(legend.position = "none") + #gets rid of legends
theme(axis.text.x = element_text(colour = "black"))+
theme(panel.spacing = unit(1, "lines")) # spaces out facet panels
pdf("/Users/zive/GDrive/research/ai_ethics/fig1.pdf",height = 7, width = 15)
print(plot.study1)
dev.off()
so}
fig1b(ai)
fig1b <- function(ai){
s1.long <- ai
s1.long$condition2 <- s1.long$domain
s1.long$variable <- s1.long$condition
s1.long$value <- s1.long$dv
s1.long$measure <-factor(s1.long$condition2,  levels = c(1,2,3,4), labels = c("Court","Hiring","Admissions","Healthcare"))
s1.long$target <-factor(s1.long$variable,  levels = c(0,1,2,3), labels = c("Control", "Codebook", "AI", "Human"))
s.1dtamean = s1.long %>% group_by(target,measure) %>% summarise(meanval = mean(value, na.rm=T), se = ci2(value))
s.1dtamean$selow = s.1dtamean$meanval - s.1dtamean$se
s.1dtamean$sehi = s.1dtamean$meanval + s.1dtamean$se
# Create plot
plot.study1 <- ggplot()+
geom_bar(data = s.1dtamean, aes(x = target, fill = measure, y = meanval),position ='dodge', stat = 'identity', with = .5, colour = "black") +
geom_errorbar(data = s.1dtamean, aes(x = target, fill = target,ymin = selow, ymax = sehi, width = .4),position = 'dodge') +
theme_classic() + # Make graph background blank
facet_grid(. ~ measure)+ #for horizontal faceting, use: facet_wrap(~measure)
geom_jitter(data = s1.long, aes(color = target, x = target, group = target,y = value), alpha = .3)+
labs(title="", x="", y = "Average Responsibility") +
scale_fill_manual(name = '',values=c('#ffffff', '#ffffff',"#ffffff","#ffffff","#ffffff","#ffffff","#ffffff","#ffffff",'#ffffff', '#ffffff',"#ffffff","#ffffff","#ffffff","#ffffff","#ffffff","#ffffff"))+ #makes bars filled with white (#f0f0f0 for off-white), but also adds the unnecessary legend
theme(legend.position = "none") + #gets rid of legends
theme(axis.text.x = element_text(colour = "black"))+
theme(panel.spacing = unit(1, "lines")) # spaces out facet panels
pdf("~/Documents/github/ai_ethics/study4/fig1.pdf",height = 7, width = 15)
print(plot.study1)
dev.off()
}
fig1b(ai)
s1.long <- ai
s1.long$condition2 <- s1.long$domain
s1.long$variable <- s1.long$condition
s1.long$value <- s1.long$dv
s1.long$measure <-factor(s1.long$condition2,  levels = c(1,2,3,4), labels = c("Court","Hiring","Admissions","Healthcare"))
s1.long$target <-factor(s1.long$variable,  levels = c(0,1,2,3), labels = c("Control", "Codebook", "AI", "Human"))
s.1dtamean = s1.long %>% group_by(target,measure) %>% summarise(meanval = mean(value, na.rm=T), se = ci2(value))
s.1dtamean$selow = s.1dtamean$meanval - s.1dtamean$se
s.1dtamean$sehi = s.1dtamean$meanval + s.1dtamean$se
plot.study1 <- ggplot()+
geom_bar(data = s.1dtamean, aes(x = target, fill = measure, y = meanval),position ='dodge', stat = 'identity', with = .5, colour = "black") +
geom_errorbar(data = s.1dtamean, aes(x = target, fill = target,ymin = selow, ymax = sehi, width = .4),position = 'dodge') +
theme_classic() + # Make graph background blank
facet_grid(. ~ measure)+ #for horizontal faceting, use: facet_wrap(~measure)
geom_jitter(data = s1.long, aes(color = target, x = target, group = target,y = value), alpha = .3)+
labs(title="", x="", y = "Average Responsibility") +
scale_fill_manual(name = '',values=c('#ffffff', '#ffffff',"#ffffff","#ffffff","#ffffff","#ffffff","#ffffff","#ffffff",'#ffffff', '#ffffff',"#ffffff","#ffffff","#ffffff","#ffffff","#ffffff","#ffffff"))+ #makes bars filled with white (#f0f0f0 for off-white), but also adds the unnecessary legend
theme(legend.position = "none") + #gets rid of legends
theme(axis.text.x = element_text(colour = "black"))+
theme(panel.spacing = unit(1, "lines")) # spaces out facet panels
s.1dtamean
plot.study1 <- ggplot()+
geom_bar(data = s.1dtamean, aes(x = target, fill = measure, y = meanval),position ='dodge', stat = 'identity', with = .5, colour = "black")
plot.study1 <- ggplot()+
geom_bar(data = s.1dtamean, aes(x = target, fill = measure, y = meanval),position ='dodge', stat = 'identity', width = .5, colour = "black")
plot.study1
plot.study1 <- ggplot()+
geom_bar(data = s.1dtamean, aes(x = target, fill = measure, y = meanval),position ='dodge', stat = 'identity', width = .5, colour = "black")+
geom_errorbar(data = s.1dtamean, aes(x = target, fill = target,ymin = selow, ymax = sehi, width = .4),position = 'dodge') +
theme_classic() + # Make graph background blank
facet_grid(. ~ measure)+ #for horizontal faceting, use: facet_wrap(~measure)
geom_jitter(data = s1.long, aes(color = target, x = target, group = target,y = value), alpha = .3)+
labs(title="", x="", y = "Average Responsibility") +
scale_fill_manual(name = '',values=c('#ffffff', '#ffffff',"#ffffff","#ffffff","#ffffff","#ffffff","#ffffff","#ffffff",'#ffffff', '#ffffff',"#ffffff","#ffffff","#ffffff","#ffffff","#ffffff","#ffffff"))+ #makes bars filled with white (#f0f0f0 for off-white), but also adds the unnecessary legend
theme(legend.position = "none") + #gets rid of legends
theme(axis.text.x = element_text(colour = "black"))+
theme(panel.spacing = unit(1, "lines")) # spaces out facet panels
pdf("~/Documents/github/ai_ethics/study4/fig1.pdf",height = 7, width = 15)
print(plot.study1)
dev.off()
ai <- read_csv("~/Documents/github/ai_ethics/study4/ai not my fault - v3_May 19, 2021_08.11.csv")
dim(ai)
ai <- read_csv("~/Documents/github/ai_ethics/study4/ai not my fault - v3_May 19, 2021_08.11.csv")
dim(ai)
ai <- ai %>% mutate(
consultant_bias = as.numeric(consultant_bias),
consultant_bias = case_when(
consultant_bias == 6 ~ 4,
consultant_bias < 4 ~ consultant_bias,
consultant_bias >6 ~ consultant_bias - 3
),
error_prone = as.numeric(error_prone),
error_prone = case_when(
error_prone < 4 ~ error_prone ,
error_prone >3 ~ error_prone - 2,
),
bc = as.numeric(bernardcheck ==case_when(
domain==1 ~ 1,
domain==2 ~ 2,
domain==3 ~ 2,
domain==4 ~ 3
)),
jc = as.numeric(jerrycheck ==case_when(
domain==1 ~ 4,
domain==2 ~ 5,
domain==3 ~ 7,
domain==4 ~ 9
)),
rc = is.na(random_check),
dv = (dv_bias + dv_racist + dv_investigate + dv_antibias + dv_responsible + dv_sue_jerry + dv_sue_org)/7
) %>% filter( rc + jc + bc ==3)
dim(ai)
table(ai$ethnicity)/nrow(ai)
table(ai$gender)/nrow(ai)
mean(ai$age)
mean(ai$Age)
mean(ai$age, na.rm=T)
p <- prcomp(dv); summary(p)
psych::alpha(dv)
ai$condition
table(ai$condition)
m <- lm("dv ~ is_human + is_manual+is_ai", data=ai); summary(m)
ai$is_human = as.numeric(condition == 3)
ai$is_manual = as.numeric(condition == 1)
ai$is_ai = as.numeric(condition == 2)
m <- lm("dv ~ is_human + is_manual+is_ai", data=ai); summary(m)
ai$is_human = as.numeric(ai$condition == 3)
ai$is_manual = as.numeric(ai$condition == 1)
ai$is_ai = as.numeric(ai$condition == 2)
m <- lm("dv ~ is_human + is_manual+is_ai", data=ai); summary(m)
ai$domain
m <- lmer("dv ~ is_human + is_manual+is_ai + (1+ is_human + is_manual+is_ai | as.factor(domain))", data=ai); summary(m)
ai$domain = as.factor(ai$domain)
m <- lmer("dv ~ is_human + is_manual+is_ai + (1+ is_human + is_manual+is_ai | as.factor(domain))", data=ai); summary(m)
m <- lmer("dv ~ is_human + is_manual+is_ai + (1+ is_human + is_manual+is_ai | domain)", data=ai); summary(m)
ai$Q169
ai$Q169_1
ai$Q173_1
ai$Q175_1
ai$Q177_1
ai$Q177_1
table(ai$condition, is.na(ai$Q177_1))
table(ai$domain, is.na(ai$Q177_1))
table(ai$domain, is.na(ai$Q175_1))
table(ai$domain, is.na(ai$Q173_1))
table(ai$domain, is.na(ai$Q169_1))
ai$Q175_1 + ai$Q177_1
coalesce(ai$Q175_1, ai$Q177_1)
table(ai$domain, is.na(coalesce(ai$Q175_1, ai$Q177_1)))
table(ai$domain, is.na(coalesce(ai$Q169_1, ai$Q173_1, ai$Q175_1, ai$Q177_1)))
ai$acc <- coalesce(ai$Q169_1, ai$Q173_1, ai$Q175_1, ai$Q177_1)
m <- lmer("acc ~ is_human + is_manual+is_ai + (1+ is_human + is_manual+is_ai | domain)", data=ai); summary(m)
m <- lmer("acc ~ is_human + is_manual + (1+ is_human + is_manual+is_ai | domain)", data=ai); summary(m)
library(lmerTest)
m <- lmer("acc ~ is_human + is_manual + (1+ is_human + is_manual+is_ai | domain)", data=ai); summary(m)
m <- lmer("acc ~ is_human + is_manual", data=ai); summary(m)
m <- lm("acc ~ is_human + is_manual", data=ai); summary(m)
ggplot()+
geom_bar(data = s.1dtamean, aes(x = condition, fill=condition, y = meanval),position ='dodge', stat = 'identity', with = .5, colour = "black") +
geom_errorbar(data = s.1dtamean, aes(x = condition, fill = condition,ymin = selow, ymax = sehi, width = .4),position = 'dodge') +
theme_classic()+  # Make graph background blank+
# facet_grid(. ~ condition) +#for horizontal faceting, use: facet_wrap(~measure)
geom_jitter(data = uld, aes(color = condition, x = condition, group = condition,y = d), alpha = .3)+
scale_color_manual(values=c( "#4772db", "#5c7e69"))+
labs(title="", x="", y = "Relative discernment") +
scale_fill_manual(name = '',values=c('#ffffff', '#ffffff'))+ #makes bars filled with white (#f0f0f0 for off-white), but also adds the unnecessary legend
theme(legend.position = "none") + #gets rid of legends
theme(axis.text.x = element_text(colour = "black"))+
scale_x_discrete(labels=c("Qualtrics", "Yourfeed")) +
theme(panel.spacing = unit(1, "lines")) # spaces out facet panels
s1.long <- ai
s1.long$condition2 <- s1.long$domain
s1.long$variable <- s1.long$condition
s1.long$value <- s1.long$acc
s1.long$measure <-factor(s1.long$condition2,  levels = c(1,2,3,4), labels = c("Court","Hiring","Admissions","Healthcare"))
s1.long$target <-factor(s1.long$variable,  levels = c(0,1,2,3), labels = c("Control", "Codebook", "AI", "Human"))
s.1dtamean = s1.long %>% group_by(target,measure) %>% summarise(meanval = mean(value, na.rm=T), se = ci2(value))
s.1dtamean$selow = s.1dtamean$meanval - s.1dtamean$se
s.1dtamean$sehi = s.1dtamean$meanval + s.1dtamean$se
ggplot()+
geom_bar(data = s.1dtamean, aes(x = condition, fill=condition, y = meanval),position ='dodge', stat = 'identity', with = .5, colour = "black") +
geom_errorbar(data = s.1dtamean, aes(x = condition, fill = condition,ymin = selow, ymax = sehi, width = .4),position = 'dodge') +
theme_classic()+  # Make graph background blank+
# facet_grid(. ~ condition) +#for horizontal faceting, use: facet_wrap(~measure)
geom_jitter(data = uld, aes(color = condition, x = condition, group = condition,y = d), alpha = .3)+
scale_color_manual(values=c( "#4772db", "#5c7e69"))+
labs(title="", x="", y = "Relative discernment") +
scale_fill_manual(name = '',values=c('#ffffff', '#ffffff'))+ #makes bars filled with white (#f0f0f0 for off-white), but also adds the unnecessary legend
theme(legend.position = "none") + #gets rid of legends
theme(axis.text.x = element_text(colour = "black"))+
scale_x_discrete(labels=c("Qualtrics", "Yourfeed")) +
theme(panel.spacing = unit(1, "lines")) # spaces out facet panels
ggplot()+
geom_bar(data = s.1dtamean, aes(x = target, fill = measure, y = meanval),position ='dodge', stat = 'identity', width = .5, colour = "black")+
geom_errorbar(data = s.1dtamean, aes(x = target, fill = target,ymin = selow, ymax = sehi, width = .4),position = 'dodge') +
theme_classic() + # Make graph background blank
facet_grid(. ~ measure)+ #for horizontal faceting, use: facet_wrap(~measure)
geom_jitter(data = s1.long, aes(color = target, x = target, group = target,y = value), alpha = .3)+
labs(title="", x="", y = "Average Responsibility") +
scale_fill_manual(name = '',values=c('#ffffff', '#ffffff',"#ffffff","#ffffff","#ffffff","#ffffff","#ffffff","#ffffff",'#ffffff', '#ffffff',"#ffffff","#ffffff","#ffffff","#ffffff","#ffffff","#ffffff"))+ #makes bars filled with white (#f0f0f0 for off-white), but also adds the unnecessary legend
theme(legend.position = "none") + #gets rid of legends
theme(axis.text.x = element_text(colour = "black"))+
theme(panel.spacing = unit(1, "lines")) # spaces out facet panels
s1.long <- ai %>% filter( condition!=0)
s1.long$condition2 <- s1.long$domain
s1.long$variable <- s1.long$condition
s1.long$value <- s1.long$acc
s1.long <- ai %>% filter( condition!=0)
s1.long$condition2 <- s1.long$domain
s1.long$variable <- s1.long$condition
s1.long$value <- s1.long$acc
s1.long$measure <-factor(s1.long$condition2,  levels = c(1,2,3,4), labels = c("Court","Hiring","Admissions","Healthcare"))
s1.long$target <-factor(s1.long$variable,  levels = c(1,2,3), labels = c("Codebook", "AI", "Human"))
s.1dtamean = s1.long %>% group_by(target,measure) %>% summarise(meanval = mean(value, na.rm=T), se = ci2(value))
s.1dtamean$selow = s.1dtamean$meanval - s.1dtamean$se
s.1dtamean$sehi = s.1dtamean$meanval + s.1dtamean$se
ggplot()+
geom_bar(data = s.1dtamean, aes(x = target, fill = measure, y = meanval),position ='dodge', stat = 'identity', width = .5, colour = "black")+
geom_errorbar(data = s.1dtamean, aes(x = target, fill = target,ymin = selow, ymax = sehi, width = .4),position = 'dodge') +
theme_classic() + # Make graph background blank
facet_grid(. ~ measure)+ #for horizontal faceting, use: facet_wrap(~measure)
geom_jitter(data = s1.long, aes(color = target, x = target, group = target,y = value), alpha = .3)+
labs(title="", x="", y = "Average Responsibility") +
scale_fill_manual(name = '',values=c('#ffffff', '#ffffff',"#ffffff","#ffffff","#ffffff","#ffffff","#ffffff","#ffffff",'#ffffff', '#ffffff',"#ffffff","#ffffff","#ffffff","#ffffff","#ffffff","#ffffff"))+ #makes bars filled with white (#f0f0f0 for off-white), but also adds the unnecessary legend
theme(legend.position = "none") + #gets rid of legends
theme(axis.text.x = element_text(colour = "black"))+
theme(panel.spacing = unit(1, "lines")) # spaces out facet panels
fig2a <- function(ai){
s1.long <- ai %>% filter( condition!=0)
s1.long$condition2 <- s1.long$domain
s1.long$variable <- s1.long$condition
s1.long$value <- s1.long$acc
s1.long$measure <-factor(s1.long$condition2,  levels = c(1,2,3,4), labels = c("Court","Hiring","Admissions","Healthcare"))
s1.long$target <-factor(s1.long$variable,  levels = c(1,2,3), labels = c("Codebook", "AI", "Human"))
s.1dtamean = s1.long %>% group_by(target,measure) %>% summarise(meanval = mean(value, na.rm=T), se = ci2(value))
s.1dtamean$selow = s.1dtamean$meanval - s.1dtamean$se
s.1dtamean$sehi = s.1dtamean$meanval + s.1dtamean$se
# Create plot
ggplot()+
geom_bar(data = s.1dtamean, aes(x = target, fill = measure, y = meanval),position ='dodge', stat = 'identity', width = .5, colour = "black")+
geom_errorbar(data = s.1dtamean, aes(x = target, fill = target,ymin = selow, ymax = sehi, width = .4),position = 'dodge') +
theme_classic() + # Make graph background blank
facet_grid(. ~ measure)+ #for horizontal faceting, use: facet_wrap(~measure)
geom_jitter(data = s1.long, aes(color = target, x = target, group = target,y = value), alpha = .3)+
labs(title="", x="", y = "Average Responsibility") +
scale_fill_manual(name = '',values=c('#ffffff', '#ffffff',"#ffffff","#ffffff","#ffffff","#ffffff","#ffffff","#ffffff",'#ffffff', '#ffffff',"#ffffff","#ffffff","#ffffff","#ffffff","#ffffff","#ffffff"))+ #makes bars filled with white (#f0f0f0 for off-white), but also adds the unnecessary legend
theme(legend.position = "none") + #gets rid of legends
theme(axis.text.x = element_text(colour = "black"))+
theme(panel.spacing = unit(1, "lines")) # spaces out facet panels
}
ggplot()+
geom_bar(data = s.1dtamean, aes(x = target, fill = measure, y = meanval),position ='dodge', stat = 'identity', width = .5, colour = "black")+
geom_errorbar(data = s.1dtamean, aes(x = target, fill = target,ymin = selow, ymax = sehi, width = .4),position = 'dodge') +
theme_classic() + # Make graph background blank
facet_grid(. ~ measure)+ #for horizontal faceting, use: facet_wrap(~measure)
geom_jitter(data = s1.long, aes(color = target, x = target, group = target,y = value), alpha = .3)+
labs(title="", x="", y = "Percived Accuracy") +
scale_fill_manual(name = '',values=c('#ffffff', '#ffffff',"#ffffff","#ffffff","#ffffff","#ffffff","#ffffff","#ffffff",'#ffffff', '#ffffff',"#ffffff","#ffffff","#ffffff","#ffffff","#ffffff","#ffffff"))+ #makes bars filled with white (#f0f0f0 for off-white), but also adds the unnecessary legend
theme(legend.position = "none") + #gets rid of legends
theme(axis.text.x = element_text(colour = "black"))+
theme(panel.spacing = unit(1, "lines")) # spaces out facet panels
m <- lmer("acc ~ is_human + is_manual + (1+ is_human + is_manual+is_ai | domain)", data=ai); summary(m)
m <- lm("acc ~ is_human + is_manual", data=ai); summary(m)
version()
version
install.packages("brms")
library(brms)
ai$acc <- coalesce(ai$Q169_1, ai$Q173_1, ai$Q175_1, ai$Q177_1)/100
m <- lmer("acc ~ is_human + is_manual + (1+ is_human + is_manual+is_ai | domain)", data=ai); summary(m)
m <- lm("acc ~ is_human + is_manual", data=ai); summary(m)
acc <-
brm(data = ai,
family = gaussian,
formula = acc ~ is_human + is_manual +
(1+ is_human + is_manual+is_ai | domain),
prior = c(prior(normal(0.5, .25), class = Intercept), #start with vague and uninformative prior - 0.5.
prior(normal(0, 0.25),    class = b),#b is all the slopes. we expect >0 (maybe 0.05, change variation) #class = b, coef="veracity" #remove priors on 25+27 (21+22)
prior(exponential(14),   class = sd), #sd governs the SD of the fixed effects of the random cluster. can only be positive so exponential
prior(exponential(1),    class = sigma),  #noise param, whats left over. fine as exp(1). if zed(continuous) then easy to set as exp(1)
prior(lkj(2),            class = cor)), #prior on covariance structure. intercept and slope within cluster
iter = 4000, warmup = 1000, chains = 4, cores = 4, seed = 42, #warmup=1000 is good. iter=3000 is chill too.  #1 chain per core
control = list(adapt_delta = 0.92), #not default, default = 0.8, if step size is too large,adjust
file = "../models/acc1")
acc <-
brm(data = ai,
family = gaussian,
formula = acc ~ is_human + is_manual +
(1+ is_human + is_manual+is_ai | domain),
prior = c(prior(normal(0.5, .25), class = Intercept), #start with vague and uninformative prior - 0.5.
prior(normal(0, 0.25),    class = b),#b is all the slopes. we expect >0 (maybe 0.05, change variation) #class = b, coef="veracity" #remove priors on 25+27 (21+22)
prior(exponential(14),   class = sd), #sd governs the SD of the fixed effects of the random cluster. can only be positive so exponential
prior(exponential(1),    class = sigma),  #noise param, whats left over. fine as exp(1). if zed(continuous) then easy to set as exp(1)
prior(lkj(2),            class = cor)), #prior on covariance structure. intercept and slope within cluster
iter = 4000, warmup = 1000, chains = 4, cores = 4, seed = 42, #warmup=1000 is good. iter=3000 is chill too.  #1 chain per core
control = list(adapt_delta = 0.92), #not default, default = 0.8, if step size is too large,adjust
file = "../models/acc1")
acc <-
brm(data = ai,
family = gaussian,
formula = acc ~ is_human + is_manual +
(1+ is_human + is_manual+is_ai | domain),
prior = c(prior(normal(0.5, .25), class = Intercept), #start with vague and uninformative prior - 0.5.
prior(normal(0, 0.25),    class = b),#b is all the slopes. we expect >0 (maybe 0.05, change variation) #class = b, coef="veracity" #remove priors on 25+27 (21+22)
prior(exponential(14),   class = sd), #sd governs the SD of the fixed effects of the random cluster. can only be positive so exponential
prior(exponential(1),    class = sigma),  #noise param, whats left over. fine as exp(1). if zed(continuous) then easy to set as exp(1)
prior(lkj(2),            class = cor)), #prior on covariance structure. intercept and slope within cluster
iter = 4000, warmup = 1000, chains = 4, cores = 4, seed = 42, #warmup=1000 is good. iter=3000 is chill too.  #1 chain per core
control = list(adapt_delta = 0.92), #not default, default = 0.8, if step size is too large,adjust
file = "/Users/ziv.e/Documents/github/ai_ethics/model/acc1")
acc <-
brm(data = ai,
family = gaussian,
formula = acc ~ is_human + is_manual +
(1+ is_human + is_manual+is_ai | domain),
prior = c(prior(normal(0.5, .25), class = Intercept), #start with vague and uninformative prior - 0.5.
prior(normal(0, 0.25),    class = b),#b is all the slopes. we expect >0 (maybe 0.05, change variation) #class = b, coef="veracity" #remove priors on 25+27 (21+22)
prior(exponential(14),   class = sd), #sd governs the SD of the fixed effects of the random cluster. can only be positive so exponential
prior(exponential(1),    class = sigma),  #noise param, whats left over. fine as exp(1). if zed(continuous) then easy to set as exp(1)
prior(lkj(2),            class = cor)), #prior on covariance structure. intercept and slope within cluster
iter = 4000, warmup = 1000, chains = 4, cores = 4, seed = 42, #warmup=1000 is good. iter=3000 is chill too.  #1 chain per core
control = list(adapt_delta = 0.92), #not default, default = 0.8, if step size is too large,adjust
file = "/Users/ziv.e/Documents/github/ai_ethics/models/acc1")
summary(acc)
prior = c(prior(normal(0.5, .25), class = Intercept), #start with vague and uninformative prior - 0.5.
prior(normal(0, 0.25),    class = b),#b is all the slopes. we expect >0 (maybe 0.05, change variation) #class = b, coef="veracity" #remove priors on 25+27 (21+22)
prior(exponential(14),   class = sd), #sd governs the SD of the fixed effects of the random cluster. can only be positive so exponential
prior(exponential(1),    class = sigma),  #noise param, whats left over. fine as exp(1). if zed(continuous) then easy to set as exp(1)
prior(lkj(2),            class = cor)), #prior on covariance structure. intercept and slope within cluster
iter = 4000, warmup = 1000, chains = 4, cores =
prior = c(prior(normal(0.5, .25), class = Intercept), #start with vague and uninformative prior - 0.5.
prior(normal(0, 0.25),    class = b),#b is all the slopes. we expect >0 (maybe 0.05, change variation) #class = b, coef="veracity" #remove priors on 25+27 (21+22)
prior(exponential(14),   class = sd), #sd governs the SD of the fixed effects of the random cluster. can only be positive so exponential
prior(exponential(1),    class = sigma),  #noise param, whats left over. fine as exp(1). if zed(continuous) then easy to set as exp(1)
prior(lkj(2),            class = cor))
prior
?brm
getOption("mc.cores", 1)
acc <- brm(data = ai,family = gaussian,formula = acc ~ is_human + is_manual + (1+ is_human + is_manual+is_ai | domain),
prior = prior,iter = 4000, warmup = 1000, cores = 4, seed = 42, control = list(adapt_delta = 0.92),
file = "/Users/ziv.e/Documents/github/ai_ethics/models/acc1")
dv <- brm(data = ai,family = gaussian,formula = dv ~ is_human + is_manual +is_ai+ (1+ is_human + is_manual+is_ai | domain),
prior = prior,iter = 4000, warmup = 1000, cores = 4, seed = 42, control = list(adapt_delta = 0.92),
file = "/Users/ziv.e/Documents/github/ai_ethics/models/dv1")
samples <- posterior_samples(dv)
samples$b_is_human
samples$b_is_human - samples$is_manual
samples$b_is_human - samples$b_is_manual
hist(samples$b_is_human - samples$b_is_manual)
summary(dv)
hist(samples$b_is_human - samples$b_is_manual)
blo <- quantile(delta, c(0.025, 0.975))
delta <- samples$b_is_human - samples$b_is_manual
blo <- quantile(delta, c(0.025, 0.975))
quantile(delta, c(0.025, 0.975))
dv
ai$Q275
ai$Q275_4
ai$Q276_4
ai$Q277_4
ai$Q281_4
ai$Q269_4
ai$Q271_4
ai %>% mutate(
ai_post = coalesce(Q275_4,Q281_4,Q269_4)
)
ai <- ai %>% mutate(
ai_post = coalesce(Q275_4,Q281_4,Q269_4)
)
ai$ai_post
table(is.na(ai$ai_post), ai$domain
)
table(is.na(ai$ai_post), ai$domain)
ai <- ai %>% mutate(
ai_post = coalesce(Q275_4,Q281_4,Q87_4, Q269_4)
)
ai <- ai %>% mutate(
ai_post = coalesce(Q275_4,Q281_4,Q287_4, Q269_4)
)
table(is.na(ai$ai_post), ai$domain)
table(is.na(ai$ai_post), ai$condition)
ai <- ai %>% mutate(
ai_post = coalesce(Q275_4,Q281_4,Q287_4, Q269_4),
ai_post = coalesce(Q275_4,Q281_4,Q287_4, Q269_4),
)
ai <- ai %>% mutate(
manual_post = coalesce(Q275_4,Q281_4,Q287_4, Q269_4),
ai_post = coalesce(Q276_4,Q282_4,Q288_4, Q270_4),
human_post = coalesce(Q277_4,Q283_4,Q289_4, Q271_4),
)
table(is.na(ai$ai_post), ai$domain)
table(is.na(ai$ai_post), ai$condition)
table(is.na(ai$manual_post), ai$condition)
table(is.na(ai$human_post), ai$condition)
?reshape
reshape(ai, varying = c("acc","manual_post","ai_post","human_post"))
reshape(ai, varying = c("acc","manual_post","ai_post","human_post"), direction ="long")
reshape(ai, varying = c("acc","manual_post","ai_post","human_post"), direction ="long", timevar ="acc_score")
?gather
itemcode <- ai$ResponseId
response <- "response"
long <- gather(ai, itemcode, "acc_score", c("acc","manual_post","ai_post","human_post"))
View(long)
long$acc_score
dim(long)
dim(ai)
dim(ai)*4
long$acc_score
View(long)
long$itemcode
table(long$itemcode)
long %>% mutate(
post = grepl("_post", itemcode)
)
long <- long %>% mutate(
post = grepl("_post", itemcode)
)
long$post
table(long$post, long$itemcode)
long <- long %>% mutate(
post = grepl("_post", itemcode),
ai_rating = grepl("ai_", itemcode) | condition==2,
)
long <- long %>% mutate(
post = grepl("_post", itemcode),
ai_rating = grepl("ai_", itemcode) | condition==2,
manual_rating = grepl("manual_", itemcode) | condition==1,
ai_rating = grepl("human_", itemcode) | condition==3,
)
table(long$manual_rating, long$condition)
table(long$ai_rating, long$condition)
table(long$human_rating, long$condition)
long <- long %>% mutate(
post = grepl("_post", itemcode),
ai_rating = grepl("ai_", itemcode) | condition==2,
manual_rating = grepl("manual_", itemcode) | condition==1,
human_rating = grepl("human_", itemcode) | condition==3,
)
table(long$human_rating, long$condition)
table(long$ai_rating, long$condition)
table(long$ai_rating, long$post)
long <- long %>% mutate(
post = grepl("_post", itemcode),
ai_rating = grepl("ai_", itemcode) | (condition==2 & itemcode == 'acc') ,
manual_rating = grepl("manual_", itemcode) | (condition==1& itemcode == 'acc'),
human_rating = grepl("human_", itemcode) | (condition==3& itemcode == 'acc'),
)
table(long$ai_rating, long$post)
table(long$ai_rating, long$condition)
View(long[,c("ai_rating", "post", "acc","itemcode")])
View(long[,c("ai_rating", "post", "acc","itemcode")])
long[,c("ai_rating", "post", "acc","itemcode")]
View(long[,c("ai_rating", "post","itemcode")])
View(long[,c("ai_rating", "post","itemcode", "acc_score")])
View(long[,c("ai_rating", "post","itemcode", "acc_score", "condition")])
long <- long %>% filter(~is.na(acc_score)) %>% mutate(
post = grepl("_post", itemcode),
ai_rating = grepl("ai_", itemcode) | (condition==2 & itemcode == 'acc') ,
manual_rating = grepl("manual_", itemcode) | (condition==1& itemcode == 'acc'),
human_rating = grepl("human_", itemcode) | (condition==3& itemcode == 'acc'),
)
long <- long %>% filter(!is.na(acc_score)) %>% mutate(
post = grepl("_post", itemcode),
ai_rating = grepl("ai_", itemcode) | (condition==2 & itemcode == 'acc') ,
manual_rating = grepl("manual_", itemcode) | (condition==1& itemcode == 'acc'),
human_rating = grepl("human_", itemcode) | (condition==3& itemcode == 'acc'),
)
table(long$ai_rating, long$condition)
long <- long %>% filter(!is.na(acc_score)) %>% mutate(
post = scale(grepl("_post", itemcode)),
ai_rating = grepl("ai_", itemcode) | (condition==2 & itemcode == 'acc') ,
manual_rating = grepl("manual_", itemcode) | (condition==1& itemcode == 'acc'),
human_rating = grepl("human_", itemcode) | (condition==3& itemcode == 'acc'),
)
long$post
dim(long)
table(long$ResponseId)
long$acc_score
acc <- brm(data = long,family = gaussian,formula = acc_score ~ post*(human_rating + manual_rating) + (1+ human_rating + manual_rating | domain)+ (1+ human_rating + manual_rating | ResponseId),
prior = prior,iter = 4000, warmup = 1000, cores = 4, seed = 42, control = list(adapt_delta = 0.92),
file = "/Users/ziv.e/Documents/github/ai_ethics/models/acc_scores")
parallel::detectCores()
summary(acc)
ai$acc
dv2 <- brm(data = ai %>% filter(condition!=0),family = gaussian,formula = dv ~ (is_human + is_manual)*acc+ (1+ is_human + is_manual+acc | domain),
prior = prior,iter = 4000, warmup = 1000, cores = 4, seed = 42, control = list(adapt_delta = 0.92),
file = "/Users/ziv.e/Documents/github/ai_ethics/models/dv2")
summary(dv2)
library(tidyverse)
library(spotifyr)
install.packaes("spotifyr")
install.packages("spotifyr")
devtools::install_github('charlie86/spotifyr')
library(devtools)
install.packages("devtools")
library(devtools)
devtools::install_github('charlie86/spotifyr')
library(spotifyr)
access_token <- get_spotify_access_token(client_id = Sys.getenv('SPOTIFY_CLIENT_ID'),
client_secret = Sys.getenv('SPOTIFY_CLIENT_SECRET'))
